package Simulator;

import com.google.gson.Gson;

import java.util.HashMap;
import java.util.Random;

public class Fsign {
    private int[] players_key;
    Gson gson = new Gson();
    // Integer: sender ID/ public key; Long: signature; Message: message to be
    // signed
    private HashMap<Integer, HashMap<Long, String>> signed_messages;
    Random rand = new Random();

    /**
     * Set the private keys for corresponding public id
     * 
     * @param keys An integer array, keys[i] is the private key for the player whose
     *             public id is i
     */
    public void setKeys(int[] keys) {
        players_key = keys;
    }

    /**
     * Initialize Fsign, initialize the singed_message.
     */
    public Fsign() {
        signed_messages = new HashMap<>();
    }

    /**
     * A player should call this function when she wants to sign a message. It will
     * generate a random new long
     * and remember the long for the specific player who sends this message and the
     * message. Then it will return a
     * Json object of singedM class.
     * 
     * @param msg         The message the sender wants to sign
     * @param sender      The sender's public id
     * @param private_key The sender's private key
     * @return A json object of SignedM class, which contains String:msg which is
     *         the message, int:player which is
     *         the sender, and long:sig which is the signature generated by Fsign.
     */
    public String sign(String msg, int sender, int private_key) {
        if (players_key[sender] != private_key)
            return null;
        long sig = rand.nextLong();
        if (!signed_messages.containsKey(sender)) {
            HashMap<Long, String> player_all_signed_msg = new HashMap<Long, String>();
            player_all_signed_msg.put(sig, msg);
            signed_messages.put(sender, player_all_signed_msg);
        } else {
            HashMap<Long, String> player_all_signed_msg = signed_messages.get(sender);
            while (player_all_signed_msg.containsKey(sig)) {
                sig = rand.nextLong();
            }
            player_all_signed_msg.put(sig, msg);
        }
        // SignedM m = new SignedM(msg, sender,sig);
        // return gson.toJson(m);
        return String.valueOf(sig);
    }

    /**
     * A player should call this function if he wants to verify whether a message is
     * signed by a specific player.
     * 
     * @param player_id the id of the player who claims to sign this message, which
     *                  is also the public key here
     * @param msg       the message he sends
     * @param sig       the signature provided by him
     * @return true if the sender indeed signed the message, false otherwise
     */
    public boolean verification(int player_id, String msg, String sig) {
        try {
            HashMap<Long, String> player_all_signed_msg = signed_messages.get(player_id);
            String message = player_all_signed_msg.get(Long.parseLong(sig));
            return message.equals(msg);
        } catch (Exception e) {
            return false;
        }
    }
}
